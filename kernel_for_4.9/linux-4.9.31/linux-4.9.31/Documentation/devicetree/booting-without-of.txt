           Booting the Linux/ppc kernel without Open Firmware
           --------------------------------------------------

(c) 2005 Benjamin Herrenschmidt <benh at kernel.crashing.org>,
    IBM Corp.
(c) 2005 Becky Bruce <becky.bruce at freescale.com>,
    Freescale Semiconductor, FSL SOC and 32-bit additions
(c) 2006 MontaVista Software, Inc.
    Flash chip node definition

Table of Contents
=================

  I - Introduction
    1) Entry point for arch/arm
    2) Entry point for arch/powerpc
    3) Entry point for arch/x86
    4) Entry point for arch/mips/bmips
    5) Entry point for arch/sh

  II - The DT block format
    1) Header
    2) Device tree generalities
    3) Device tree "structure" block
    4) Device tree "strings" block

  III - Required content of the device tree
    1) Note about cells and address representation
    2) Note about "compatible" properties
    3) Note about "name" properties
    4) Note about node and property names and character set
    5) Required nodes and properties
      a) The root node
      b) The /cpus node
      c) The /cpus/* nodes
      d) the /memory node(s)
      e) The /chosen node
      f) the /soc<SOCname> node

  IV - "dtc", the device tree compiler

  V - Recommendations for a bootloader

  VI - System-on-a-chip devices and nodes
    1) Defining child nodes of an SOC
    2) Representing devices without a current OF specification

  VII - Specifying interrupt information for devices
    1) interrupts property
    2) interrupt-parent property
    3) OpenPIC Interrupt Controllers
    4) ISA Interrupt Controllers

  VIII - Specifying device power management information (sleep property)

  IX - Specifying dma bus information

  Appendix A - Sample SOC node for MPC8540


Revision Information
====================

   May 18, 2005: Rev 0.1 - Initial draft, no chapter III yet.

   May 19, 2005: Rev 0.2 - Add chapter III and bits & pieces here or
                           clarifies the fact that a lot of things are
                           optional, the kernel only requires a very
                           small device tree, though it is encouraged
                           to provide an as complete one as possible.

   May 24, 2005: Rev 0.3 - Precise that DT block has to be in RAM
			 - Misc fixes
			 - Define version 3 and new format version 16
			   for the DT block (version 16 needs kernel
			   patches, will be fwd separately).
			   String block now has a size, and full path
			   is replaced by unit name for more
			   compactness.
			   linux,phandle is made optional, only nodes
			   that are referenced by other nodes need it.
			   "name" property is now automatically
			   deduced from the unit name

   June 1, 2005: Rev 0.4 - Correct confusion between OF_DT_END and
                           OF_DT_END_NODE in structure definition.
                         - Change version 16 format to always align
                           property data to 4 bytes. Since tokens are
                           already aligned, that means no specific
                           required alignment between property size
                           and property data. The old style variable
                           alignment would make it impossible to do
                           "simple" insertion of properties using
                           memmove (thanks Milton for
                           noticing). Updated kernel patch as well
			 - Correct a few more alignment constraints
			 - Add a chapter about the device-tree
                           compiler and the textural representation of
                           the tree that can be "compiled" by dtc.

   November 21, 2005: Rev 0.5
			 - Additions/generalizations for 32-bit
			 - Changed to reflect the new arch/powerpc
			   structure
			 - Added chapter VI


 ToDo:
	- Add some definitions of interrupt tree (simple/complex)
	- Add some definitions for PCI host bridges
	- Add some common address format examples
	- Add definitions for standard properties and "compatible"
	  names for cells that are not already defined by the existing
	  OF spec.
	- Compare FSL SOC use of PCI to standard and make sure no new
	  node definition required.
	- Add more information about node definitions for SOC devices
  	  that currently have no standard, like the FSL CPM.


I - Introduction
================
随着Linux/ppc64内核的发展，更具体的说,除了老的IBM 
pSeries/iSeries一对添加新的平台类型，它决定执行一些严格的规则关于这个内核的条目和bootloadler，内核接口
为了避免的   差异     成为ppc32内核入口点和一个新平台的方式应该被添加到内核。
遗留的iSeries平台在该方案出现之前就违反了这些规则，
但是在主树中没有任何新的董事会支持，因为主树不能正确地执行这些规则。此外，由于
powerpc和ppc32和ppc64的架构的出现，新的32位平台和32位的平台也需要使用这些规则。

During the development of the Linux/ppc64 kernel, and more
specifically, the addition of new platform types outside of the old
IBM pSeries/iSeries pair, it was decided to enforce some strict rules
regarding the kernel entry and bootloader <-> kernel interfaces, in
order to avoid the degeneration that had become the ppc32 kernel entry
point and the way a new platform should be added to the kernel. The
legacy iSeries platform breaks those rules as it predates this scheme,
but no new board support will be accepted in the main tree that
doesn't follow them properly.  In addition, since the advent of the
arch/powerpc merged architecture for ppc32 and ppc64, new 32-bit
platforms and 32-bit platforms which move into arch/powerpc will be
required to use these rules as well.

下面将详细定义的主要需求是一个设备树的存在
它的格式是在开放的固件规范之后定义的
然而，为了让嵌入式板供应商的生活更轻松
内核不需要设备树来表示系统中的每一个设备
只需要一些节点和属性就可以了。这将在第三节中详细描述，但是
但是，例如，内核不要求您为系统中的每一个PCI设备创建一个节点
为了提供中断路由信息和内存/io范围，需要有一个PCI主机桥接的节点
还建议在芯片设备和其他总线上定义节点，而这些节点并不特别适合于现有OF  的规范
这样，内核就可以在不需要硬编码各种表的情况下，对内核进行探测

The main requirement that will be defined in more detail below is
the presence of a device-tree whose format is defined after Open
Firmware specification. However, in order to make life easier
to embedded board vendors, the kernel doesn't require the device-tree
to represent every device in the system and only requires some nodes
and properties to be present. This will be described in detail in
section III, but, for example, the kernel does not require you to
create a node for every PCI device in the system. It is a requirement
to have a node for PCI host bridges in order to provide interrupt
routing information and memory/IO ranges, among others. It is also
recommended to define nodes for on chip devices and other buses that
don't specifically fit in an existing OF specification. This creates a
great flexibility in the way the kernel can then probe those and match
drivers to device, without having to hard code all sorts of tables. It
also makes it more flexible for board vendors to do minor hardware
upgrades without significantly impacting the kernel code or cluttering
it with special cases.


1) Entry point for arch/arm
---------------------------
在内核映像的开始处，内核有一个单独的入口点。该入口点支持两个调用
约定。这里描述了接口的摘要。对引导需求的完整描述被记录在文档中
文档  Documentation/arm/Booting

   There is one single entry point to the kernel, at the start
   of the kernel image. That entry point supports two calling
   conventions.  A summary of the interface is described here.  A full
   description of the boot requirements is documented in
   Documentation/arm/Booting
ATAGS接口。最小的信息从固件传递到内核，并带有一个已标记的预定义参数列表
        a) ATAGS interface.  Minimal information is passed from firmware
        to the kernel with a tagged list of predefined parameters.

                r0 : 0

                r1 : Machine type number

                r2 : Physical address of tagged list in system RAM
进入一个扁平的设备树块。固件将扁平设备树块(dtb)的物理地址加载到r2中，
r1没有使用,但它被认为是良好的实践使用一个有效的机器码
        b) Entry with a flattened device-tree block.  Firmware loads the
        physical address of the flattened device tree block (dtb) into r2,
        r1 is not used, but it is considered good practice to use a valid
        machine number as described in Documentation/arm/Booting.

                r0 : 0

                r1 : Valid machine type number.  When using a device tree,
                a single machine type number will often be assigned to
                represent a class or family of SoCs.

                r2 : physical pointer to the device-tree block
                (defined in chapter II) in RAM.  Device tree can be located
                anywhere in system RAM, but it should be aligned on a 64 bit
                boundary.

   The kernel will differentiate between ATAGS and device tree booting by
   reading the memory pointed to by r2 and looking for either the flattened
   device tree block magic value (0xd00dfeed) or the ATAG_CORE value at
   offset 0x4 from r2 (0x54410001).

2) Entry point for arch/powerpc
-------------------------------

   There is one single entry point to the kernel, at the start
   of the kernel image. That entry point supports two calling
   conventions:

        a) Boot from Open Firmware. If your firmware is compatible
        with Open Firmware (IEEE 1275) or provides an OF compatible
        client interface API (support for "interpret" callback of
        forth words isn't required), you can enter the kernel with:

              r5 : OF callback pointer as defined by IEEE 1275
              bindings to powerpc. Only the 32-bit client interface
              is currently supported

              r3, r4 : address & length of an initrd if any or 0
MMU是开还是关，内核将运行 
arch/powerpc/kernel/prom_init.c中的trampoline去提取设备树和其他的信息从开源固件并在b)中构建一个扁平设备树。
prom_init将使用第二种方法重新进入内核。trampoline代码运行在固件的上下文中，他应该在那里处理所有的异常
              The MMU is either on or off; the kernel will run the
              trampoline located in arch/powerpc/kernel/prom_init.c to
              extract the device-tree and other information from open
              firmware and build a flattened device-tree as described
              in b). prom_init() will then re-enter the kernel using
              the second method. This trampoline code runs in the
              context of the firmware, which is supposed to handle all
              exceptions during that time.
直接进入一个扁平的设备树块。在trampoline之后这个入口点被a)调印， 
它也能直接被bootloader调用，它不支持代开开源硬件的客户端借口。他还被使用通过"kexec"去实现热启动从以前运行的那个
那个到运行新的内核。这个方法是我将在本文中详细描述的，作为方法a)仅仅是标准的开放固件，因此应该根据定义它的各种标准文档和它对PowerPC
平台的绑定来实现。入口点的定义就变成了
        b) Direct entry with a flattened device-tree block. This entry
        point is called by a) after the OF trampoline and can also be
        called directly by a bootloader that does not support the Open
        Firmware client interface. It is also used by "kexec" to
        implement "hot" booting of a new kernel from a previous
        running one. This method is what I will describe in more
        details in this document, as method a) is simply standard Open
        Firmware, and thus should be implemented according to the
        various standard documents defining it and its binding to the
        PowerPC platform. The entry point definition then becomes:

                r3 : physical pointer to the device-tree block
                (defined in chapter II) in RAM
                
物理指针指向内核它本身            如果您使用MMU启用了MMU和一个非1:1映射，那么汇编代码将使用汇编代码来正确地禁用
MMU。
                r4 : physical pointer to the kernel itself. This is
                used by the assembly code to properly disable the MMU
                in case you are entering the kernel with MMU enabled
                and a non-1:1 mapping.

                r5 : NULL (as to differentiate with method a)
要么是你的固件把你的其他cpu放在某个睡眠循环中，要么是在ROM上的旋转循环，
你可以通过软重置或其他方式把它们弄出来，在这种情况下，你不需要关心，或者你必须
用所有的cpu来输入内核。方法b 的方法)将在后面的修订本文档中进行描述
        Note about SMP entry: Either your firmware puts your other
        CPUs in some sleep loop or spin loop in ROM where you can get
        them out via a soft reset or some other means, in which case
        you don't need to care, or you'll have to enter the kernel
        with all CPUs. The way to do that with method b) will be
        described in a later revision of this document.
板支持(平台)不是唯一的配置选项。可以在单个内核映像中构建任意一组板支持。
内核将“知道”基于设备树的内容对给定平台使用的功能集。因此,你应该:
   Board supports (platforms) are not exclusive config options. An
   arbitrary set of board supports can be built in a single kernel
   image. The kernel will "know" what set of functions to use for a
   given platform based on the content of the device-tree. Thus, you
   should:

        a) add your platform support as a _boolean_ option in
        arch/powerpc/Kconfig, following the example of PPC_PSERIES,
        PPC_PMAC and PPC_MAPLE. The later is probably a good
        example of a board support to start from.

        b) create your main platform file as
        "arch/powerpc/platforms/myplatform/myboard_setup.c" and add it
        to the Makefile under the condition of your CONFIG_
        option. This file will define a structure of type "ppc_md"
        containing the various callbacks that the generic code will
        use to get to your platform specific code

  A kernel image may support multiple platforms, but only if the
  platforms feature the same core architecture.  A single kernel build
  cannot support both configurations with Book E and configurations
  with classic Powerpc architectures.

3) Entry point for arch/x86
-------------------------------
在code32_start中，内核有一个32位的入口点，解压缩器(当转换为受保护模式时，真正的模式入口点进入相同的32位入口点)
该入口点支持一个调用约定在 
Documentation/x86/boot.txt被记录。对设备树块的物理指针(在第2章中定义)是通过setup_data
传递的，该数据至少需要引导协议2.09。类型文件被定义为
  There is one single 32bit entry point to the kernel at code32_start,
  the decompressor (the real mode entry point goes to the same  32bit
  entry point once it switched into protected mode). That entry point
  supports one calling convention which is documented in
  Documentation/x86/boot.txt
  The physical pointer to the device-tree block (defined in chapter II)
  is passed via setup_data which requires at least boot protocol 2.09.
  The type filed is defined as

  #define SETUP_DTB                      2
这个设备树被用作“引导页面”的扩展.因此，它不会解析/考虑已经被引导页面覆盖的数据
这包括内存大小、保留范围、命令行参数或initrd地址. 它只包含无法检索的信息，比如中断路由或I2C总线后面的设备列表。
  This device-tree is used as an extension to the "boot page". As such it
  does not parse / consider data which is already covered by the boot
  page. This includes memory size, reserved ranges, command line arguments
  or initrd address. It simply holds information which can not be retrieved
  otherwise like interrupt routing or a list of devices behind an I2C bus.

4) Entry point for arch/mips/bmips
----------------------------------
一些引导加载程序只支持一个入口点，在内核映像的开始。其他引导加载程序将跳转到ELF开始地址
这两个方案都支持;CONFIG_BOOT_RAW=y and CONFIG_NO_EXCEPT_FILL=y,因此，第一个指令立即跳转到内核条目
因此，第一个指令立即跳转到kernelentry()
  Some bootloaders only support a single entry point, at the start of the
  kernel image.  Other bootloaders will jump to the ELF start address.
  Both schemes are supported; CONFIG_BOOT_RAW=y and CONFIG_NO_EXCEPT_FILL=y,
  so the first instruction immediately jumps to kernel_entry().
类似于arch/arm案例(b)，一个有dt的引导装载程序将会设置如下的寄存器:
  Similar to the arch/arm case (b), a DT-aware bootloader is expected to
  set up the following registers:

         a0 : 0

         a1 : 0xffffffff

         a2 : Physical pointer to the device tree block (defined in chapter
         II) in RAM.  The device tree can be located anywhere in the first
         512MB of the physical address space (0x00000000 - 0x1fffffff),
         aligned on a 64 bit boundary.
遗留引导加载程序不使用这个约定，它们不会传入一个DT块
在这种情况下，Linux将寻找一个通过config_dt_选择的内置DTB
  Legacy bootloaders do not use this convention, and they do not pass in a
  DT block.  In this case, Linux will look for a builtin DTB, selected via
  CONFIG_DT_*.
这个约定仅针对32位系统定义，因为目前还没有64位BMIPS实现。
  This convention is defined for 32-bit systems only, as there are not
  currently any 64-bit BMIPS implementations.

5) Entry point for arch/sh
--------------------------
Device-tree-compatible的SH bootloaders 
可以在r4中提供设备树blob的物理地址。由于传统的bootloaders不能保证特别的初始寄存器状态
所以与旧的   bootloaders   进行交 互操作的内核必须使用一个内置的DTB
或者选择一个不使用设备树的遗留板选项(除了CONFIG_SH_DEVICE_TREE  以外的其他东西)


  Device-tree-compatible SH bootloaders are expected to provide the physical
  address of the device tree blob in r4. Since legacy bootloaders did not
  guarantee any particular initial register state, kernels built to
  inter-operate with old bootloaders must either use a builtin DTB or
  select a legacy board option (something other than CONFIG_SH_DEVICE_TREE)
  that does not use device tree. Support for the latter is being phased out
  in favor of device tree.


II - The DT block format
========================
本章定义了传递给内核的扁平设备树的实际格式。稍后将介绍it
和内核需求的实际内容。您可以在不同的地方找到这样的代码示例，包括arch/powerpc/kernel/prom_init.c
将从打开的固件表示中生成一个扁平的设备树，或者fs2dt
实用程序，它是kexec工具的一部分，它将从文件系统表示中生成一个工具。预期像uboot
这样的引导加载器提供了更多的支持，这也将在以后讨论。

This chapter defines the actual format of the flattened device-tree
passed to the kernel. The actual content of it and kernel requirements
are described later. You can find example of code manipulating that
format in various places, including arch/powerpc/kernel/prom_init.c
which will generate a flattened device-tree from the Open Firmware
representation, or the fs2dt utility which is part of the kexec tools
which will generate one from a filesystem representation. It is
expected that a bootloader like uboot provides a bit more support,
that will be discussed later as well.
注意:该块必须位于主内存中。它必须在真实模式和虚拟模式下都可以访问，除了主存之外
没有其他映射。如果您正在编写一个简单的flash
引导加载程序，那么在将它传递给内核之前，它应该将该块复制到RAM中。
Note: The block has to be in main memory. It has to be accessible in
both real mode and virtual mode with no mapping other than main
memory. If you are writing a simple flash bootloader, it should copy
the block to RAM before passing it to the kernel.


1) Header
---------
内核通过物理地址，指向一个内存区域，通过 include/linux/of_fdt.h中的 
boot_param_header结构体声明引导
   The kernel is passed the physical address pointing to an area of memory
   that is roughly described in include/linux/of_fdt.h by the structure
   boot_param_header:

struct boot_param_header {
        u32     magic;                  /* magic word OF_DT_HEADER */
        u32     totalsize;              /* total size of DT block */
        u32     off_dt_struct;          /* offset to structure */
        u32     off_dt_strings;         /* offset to strings */
        u32     off_mem_rsvmap;         /* offset to memory reserve map
                                           */
        u32     version;                /* format version */
        u32     last_comp_version;      /* last compatible version */

        /* version 2 fields below */
        u32     boot_cpuid_phys;        /* Which physical CPU id we're
                                           booting on */
        /* version 3 fields below */
        u32     size_dt_strings;        /* size of the strings block */

        /* version 17 fields below */
        u32	size_dt_struct;		/* size of the DT structure block */
};

   Along with the constants:

/* Definitions used by the flattened device tree */
#define OF_DT_HEADER            0xd00dfeed      /* 4: version,
						   4: total size */
#define OF_DT_BEGIN_NODE        0x1             /* Start node: full name
						   */
#define OF_DT_END_NODE          0x2             /* End node */
#define OF_DT_PROP              0x3             /* Property: name off,
                                                   size, content */
#define OF_DT_END               0x9
这个header 中的所有值都是大端模式的 格式
在这个header中的各个字段在下面有更精确的定义。
所有的偏移值都是从header 开始的字节开始的。这是来自设备树块的物理基础地址。
   All values in this header are in big endian format, the various
   fields in this header are defined more precisely below. All
   "offset" values are in bytes from the start of the header; that is
   from the physical base address of the device tree block.

   - magic
这是一个神奇的值，标识这设备数块的header的开始。它的值是0xd00dfeed，通过不变的OF_DT_HEADER定义
     This is a magic value that "marks" the beginning of the
     device-tree block header. It contains the value 0xd00dfeed and is
     defined by the constant OF_DT_HEADER

   - totalsize
这是DT块的总大小，包括头。DT块应该包含所有的数据结构定义在这一章的(通过头的偏移来指向改地址)。
也就是说，设备树结构、字符串和内存保留映射
     This is the total size of the DT block including the header. The
     "DT" block should enclose all data structures defined in this
     chapter (who are pointed to by offsets in this header). That is,
     the device-tree structure, strings, and the memory reserve map.

   - off_dt_struct
这是头的开始到设备树的structure部分的偏移
     This is an offset from the beginning of the header to the start
     of the "structure" part the device tree. (see 2) device tree)

   - off_dt_strings
这是从头开始到设备树的“字符串”部分开始的偏移量
     This is an offset from the beginning of the header to the start
     of the "strings" part of the device-tree

   - off_mem_rsvmap
这是从头开始到预留内存映射开始的偏移量。这个映射是多个64位整数的列表
每一对都是一个物理地址和一个大小。列表被一个大小为0的条目终止
这个映射为内核提供了一个“保留”的物理内存区域列表
因此不能用于内存分配，尤其是在早期初始化期间。内核需要在启动一些事情，诸如扁平设备树，分配MMU哈希表等之类的东西。
这个分配必须被这样的情况中完成，避免重写重要的事情比如打开固件的机器，rtas 实例，或者一些pSeries
用于iommu的表的TCE。通常保留映射应该包含at_least_这个dt块本身(header,total_size)。如果你传initrd给内核，你应该保留他。
您不需要保留内核映像本身。map 应该是64位对齐的。
     This is an offset from the beginning of the header to the start
     of the reserved memory map. This map is a list of pairs of 64-
     bit integers. Each pair is a physical address and a size. The
     list is terminated by an entry of size 0. This map provides the
     kernel with a list of physical memory areas that are "reserved"
     and thus not to be used for memory allocations, especially during
     early initialization. The kernel needs to allocate memory during
     boot for things like un-flattening the device-tree, allocating an
     MMU hash table, etc... Those allocations must be done in such a
     way to avoid overriding critical things like, on Open Firmware
     capable machines, the RTAS instance, or on some pSeries, the TCE
     tables used for the iommu. Typically, the reserve map should
     contain _at least_ this DT block itself (header,total_size). If
     you are passing an initrd to the kernel, you should reserve it as
     well. You do not need to reserve the kernel image itself. The map
     should be 64-bit aligned.

   - version
这个是这个结构体的版本，版本1停止在这里，版本2提供了一个额外的字段boot_cpuid_phys.
版本3 添加了字符串快的大小。允许内核在引导时轻松地重新分配它，并在扩展后释放未使用的扁平结构
版本16 引入了新的"紧凑"格式的，但是不想后兼容。Version 
17添加了一个额外的字段，size_dt_struct，允许它更容易地重新分配或移动(这是
对于需要进行调整基于probe 信息的设备树非常有用).您应该始终生成最高版本定义的结构
在您实现的时候。目前这是第17版，除非您明确的目标是向后兼容。
     This is the version of this structure. Version 1 stops
     here. Version 2 adds an additional field boot_cpuid_phys.
     Version 3 adds the size of the strings block, allowing the kernel
     to reallocate it easily at boot and free up the unused flattened
     structure after expansion. Version 16 introduces a new more
     "compact" format for the tree itself that is however not backward
     compatible. Version 17 adds an additional field, size_dt_struct,
     allowing it to be reallocated or moved more easily (this is
     particularly useful for bootloaders which need to make
     adjustments to a device tree based on probed information). You
     should always generate a structure of the highest version defined
     at the time of your implementation. Currently that is version 17,
     unless you explicitly aim at being backward compatible.

   - last_comp_version
最后一个兼容的版本。这表明了您向后兼容的DT块的版本。例如，版本2向后兼容版本1(
也就是说，版本1的内核构建可以使用版本2的格式启动)。如果您生成的是版本1到3
的设备树，你这里应该放1   如果您使用新的单元名称格式生成了16或17
树的树，那么您应该在该字段中放置16。
     Last compatible version. This indicates down to what version of
     the DT block you are backward compatible. For example, version 2
     is backward compatible with version 1 (that is, a kernel build
     for version 1 will be able to boot with a version 2 format). You
     should put a 1 in this field if you generate a device tree of
     version 1 to 3, or 16 if you generate a tree of version 16 or 17
     using the new unit name format.

   - boot_cpuid_phys
这个字段只存在于版本2的头中，它指示了哪个物理CPU ID调用内核入口点，这是由kexec所使用的
如果您是在SMP系统上，那么这个值应该与设备树中CPU节点的“reg”属性相匹配
该属性对应于调用内核入口点的CPU(
请参阅进一步的章节，以获得关于所需的设备-树内容的更多信息)
     This field only exist on version 2 headers. It indicate which
     physical CPU ID is calling the kernel entry point. This is used,
     among others, by kexec. If you are on an SMP system, this value
     should match the content of the "reg" property of the CPU node in
     the device-tree corresponding to the CPU calling the kernel entry
     point (see further chapters for more information on the required
     device-tree contents)

   - size_dt_strings
这个字段只存在于版本3和后面的头中
 。它给出了设备树的“ string  ”部分的大小(从
off_dt_string给出的偏移量开始)。
     This field only exists on version 3 and later headers.  It
     gives the size of the "strings" section of the device tree (which
     starts at the offset given by off_dt_strings).

   - size_dt_struct
这个字段只存在于版本17和后面的头  中。它给出了设备树的“ struct  ”部分的大小(从
offdtstruct给出的偏移量开始)
     This field only exists on version 17 and later headers.  It gives
     the size of the "structure" section of the device tree (which
     starts at the offset given by off_dt_struct).
因此，一个DT块的典型布局(尽管各个部分不需要这样的顺序)看起来是这样的(
地址从上到下):
   So the typical layout of a DT block (though the various parts don't
   need to be in that order) looks like this (addresses go from top to
   bottom):


             ------------------------------
     base -> |  struct boot_param_header  |
             ------------------------------
             |      (alignment gap) (*)   |
             ------------------------------
             |      memory reserve map    |
             ------------------------------
             |      (alignment gap)       |
             ------------------------------
             |                            |
             |    device-tree structure   |
             |                            |
             ------------------------------
             |      (alignment gap)       |
             ------------------------------
             |                            |
             |     device-tree strings    |
             |                            |
      -----> ------------------------------
      |
      |
      --- (base + totalsize)
对齐的缺口不一定存在;它们的存在和大小取决于各个数据块的各种对齐要求。
  (*) The alignment gaps are not necessarily present; their presence
      and size are dependent on the various alignment requirements of
      the individual data blocks.


2) Device tree generalities
---------------------------
这个设备树本身被分成两个不同的块，一个结构块和一个字符串块。两者都需要对齐
到一个4字节的边界。
This device-tree itself is separated in two different blocks, a
structure block and a strings block. Both need to be aligned to a 4
byte boundary.
首先，在详细描述存储格式之前，让我们快速描述一下设备树的概念
本章没有描述内核所需的节点和属性的细节，这是在第三章的后面完成的。
First, let's quickly describe the device-tree concept before detailing
the storage format. This chapter does _not_ describe the detail of the
required types of nodes & properties for the kernel, this is done
later in chapter III.
设备树的布局从开放固件IEEE 1275设备树的定义中得到了严格的继承
它基本上是一个节点树，每个节点有两个或更多的命名属性。一个属性可以有一个值。
The device-tree layout is strongly inherited from the definition of
the Open Firmware IEEE 1275 device-tree. It's basically a tree of
nodes, each node having two or more named properties. A property can
have a value or not.
它是一棵树，因此每个节点只有一个父节点,除了没有父节点的根节点之外，只有一个父节点
It is a tree, so each node has one and only one parent except for the
root node who has no parent.
一个节点有两个名称。实际的节点名通常包含在节点属性列表中的“name
”属性中，该属性值为零终止的字符串，并且对于格式定义的版本1到3(如在开放固件中)
是强制的。版本16使它成为可选的，因为它可以从下面定义的单元名称中生成它。
A node has 2 names. The actual node name is generally contained in a
property of type "name" in the node property list whose value is a
zero terminated string and is mandatory for version 1 to 3 of the
format definition (as it is in Open Firmware). Version 16 makes it
optional as it can generate it from the unit name defined below.
还有一个“单元名”，用于在同一级别上区分具有相同名称的节点，通常由节点名、“@”
符号和“单元地址”组成，该定义特定于节点所在的总线类型
There is also a "unit name" that is used to differentiate nodes with
the same name at the same level, it is usually made of the node
names, the "@" sign, and a "unit address", which definition is
specific to the bus type the node sits on.
单元名称并不作为一个属性存在，而是包含在设备树结构中。它通常用于在设备树中表示
“路径”。关于这些内容的具体格式的更多细节将会在下面。
The unit name doesn't exist as a property per-se but is included in
the device-tree structure. It is typically used to represent "path" in
the device-tree. More details about the actual format of these will be
below.
内核通用代码没有对单元地址进行任何正式的使用(尽管有一些板子支持包这么做)，
因此，对于单元地址来说，唯一真正的需求是确保节点单元名称在树的给定级别上的惟一性
没有地址的节点，没有相同名字的兄弟姐妹(比如/memory 或者是/cpus)可能会在这个规范的上下文中省略单元地址
或者使用“@0”默认的单元地址。单元名称用于定义节点“完整路径”，即所有父节点单元名称与“/”
分隔的连接。
The kernel generic code does not make any formal use of the
unit address (though some board support code may do) so the only real
requirement here for the unit address is to ensure uniqueness of
the node unit name at a given level of the tree. Nodes with no notion
of address and no possible sibling of the same name (like /memory or
/cpus) may omit the unit address in the context of this specification,
or use the "@0" default unit address. The unit name is used to define
a node "full path", which is the concatenation of all parent node
unit names separated with "/".
根节点没有定义的名称，如果您使用的是版本3
或更早的格式，则不需要有名称属性。它也没有单元地址(没有@符号，后面是单元地址)
。根节点单元名因此是一个空字符串。根节点的完整路径是“/”。
The root node doesn't have a defined name, and isn't required to have
a name property either if you are using version 3 or earlier of the
format. It also has no unit address (no @ symbol followed by a unit
address). The root node unit name is thus an empty string. The full
path to the root node is "/".
每个节点实际上代表一个实际的设备(也就是说，对于多个节点一个节点不仅仅是一个虚拟的“容器",比如“/cpus)
还需要一个“compatible  ”属性来指示特定的硬件和一个可选的设备列表，它是完全向后兼容
Every node which actually represents an actual device (that is, a node
which isn't only a virtual "container" for more nodes, like "/cpus"
is) is also required to have a "compatible" property indicating the
specific hardware and an optional list of devices it is fully
backwards compatible with.
最后，可以从另一个节点上的属性引用的每个节点都需要一个“phandle”或一个“linux
，phandle”属性。真正的开源固件实现为每个节点 
提供唯一的“phandle”值。"prom_init()跳转代码变成了linux,phandle属性。然而， 
但是，如果直接使用扁平的设备树，那么这是可选的。
一个例子对于一个节点通过phandle 引用另一个节点的例子是在布局中断树时，该节点将在该文档的另一个版本中进行描述。
Finally, every node that can be referenced from a property in another
node is required to have either a "phandle" or a "linux,phandle"
property. Real Open Firmware implementations provide a unique
"phandle" value for every node that the "prom_init()" trampoline code
turns into "linux,phandle" properties. However, this is made optional
if the flattened device tree is used directly. An example of a node
referencing another node via "phandle" is when laying out the
interrupt tree which will be described in a further version of this
document.
“phandle”属性是一个32位值,惟一地标识一个节点。你可以自由的使用任何值或者是系统的值，内部指针，或者生成这些
唯一的要求就是，你提供给每个节点的这个属性的值是唯一的

The "phandle" property is a 32-bit value that uniquely
identifies a node. You are free to use whatever values or system of
values, internal pointers, or whatever to generate these, the only
requirement is that every node for which you provide that property has
a unique value for it.
下面是一个简单的设备树的例子
在本例中，“o”指定了一个节点，后面是节点单元名称
。属性以它们的名称和内容呈现
"content"  表示一个ASCII字符串(零终止)值，而<content> 表示一个32
位的值，以十进制或十六进制(后者的前缀是0x)指定。
本例中的各个节点将在后面的章节中讨论
在这里，它只是想让您了解一个设备树是什么样子的。
我特意保留了“name”和“linux，phandle
”属性，这是不必要的，以便让您更好地了解这棵树在实际中是什么样子的。
Here is an example of a simple device-tree. In this example, an "o"
designates a node followed by the node unit name. Properties are
presented with their name followed by their content. "content"
represents an ASCII string (zero terminated) value, while <content>
represents a 32-bit value, specified in decimal or hexadecimal (the
latter prefixed 0x). The various nodes in this example will be
discussed in a later chapter. At this point, it is only meant to give
you a idea of what a device-tree looks like. I have purposefully kept
the "name" and "linux,phandle" properties which aren't necessary in
order to give you a better idea of what the tree looks like in
practice.

  / o device-tree
      |- name = "device-tree"
      |- model = "MyBoardName"
      |- compatible = "MyBoardFamilyName"
      |- #address-cells = <2>
      |- #size-cells = <2>
      |- linux,phandle = <0>
      |
      o cpus
      | | - name = "cpus"
      | | - linux,phandle = <1>
      | | - #address-cells = <1>
      | | - #size-cells = <0>
      | |
      | o PowerPC,970@0
      |   |- name = "PowerPC,970"
      |   |- device_type = "cpu"
      |   |- reg = <0>
      |   |- clock-frequency = <0x5f5e1000>
      |   |- 64-bit
      |   |- linux,phandle = <2>
      |
      o memory@0
      | |- name = "memory"
      | |- device_type = "memory"
      | |- reg = <0x00000000 0x00000000 0x00000000 0x20000000>
      | |- linux,phandle = <3>
      |
      o chosen
        |- name = "chosen"
        |- bootargs = "root=/dev/sda2"
        |- linux,phandle = <4>
这棵树几乎是最小的树。它几乎包含了引导linux内核所需的最基本的节点和属性
;也就是说，在根、cpu和物理内存布局中有一些基本的模型信息
它还包括通过/chosen  的misc信息，例如在本例中，平台类型(强制性)和内核命令行参数(可选)。
This tree is almost a minimal tree. It pretty much contains the
minimal set of required nodes and properties to boot a linux kernel;
that is, some basic model information at the root, the CPUs, and the
physical memory layout.  It also includes misc information passed
through /chosen, like in this example, the platform type (mandatory)
and the kernel command line arguments (optional).
/cpus/PowerPC,970@0 是一个没有值的属性的例子
所有其他属性都有一个值
 #address-cells和 #size-cells将在第四章解析，它定义了所需的节点和属性及其内容。
The /cpus/PowerPC,970@0/64-bit property is an example of a
property without a value. All other properties have a value. The
significance of the #address-cells and #size-cells properties will be
explained in chapter IV which defines precisely the required nodes and
properties and their content.


3) Device tree "structure" block
设备的结构线性树是一个树结构。OF_DT_BEGIN_NODE象征着一个新节点的开始
OF_DT_END_NODE象征着一个节点的结束。子节点只是之前定义“OF_DT_END_NODE”(即节点内的节点)。
'token' 是一个32位的值，树能被完成OF_DT_END

The structure of the device tree is a linearized tree structure. The
"OF_DT_BEGIN_NODE" token starts a new node, and the "OF_DT_END_NODE"
ends that node definition. Child nodes are simply defined before
"OF_DT_END_NODE" (that is nodes within the node). A 'token' is a 32
bit value. The tree has to be "finished" with a OF_DT_END token
这是一个单一节点的基本结构
Here's the basic structure of a single node:

     * token OF_DT_BEGIN_NODE (that is 0x00000001)
     * for version 1 to 3, this is the node full path as a zero
       terminated string, starting with "/". For version 16 and later,
       this is the node unit name only (or an empty string for the
       root node)
     * [align gap to next 4 bytes boundary]
     * for each property:
        * token OF_DT_PROP (that is 0x00000003)
        * 32-bit value of property value size in bytes (or 0 if no
          value)
        * 32-bit value of offset in string block of property name
        * property value data if any
        * [align gap to next 4 bytes boundary]
     * [child nodes if any]
     * token OF_DT_END_NODE (that is 0x00000002)
因此节点内容可以概括为一个开始标记
一个完整的路径,一个属性列表,子节点列表,和结束标记
每个子节点本身就是一个完整的节点结构定义。

So the node content can be summarized as a start token, a full path,
a list of properties, a list of child nodes, and an end token. Every
child node is a full node structure itself as defined above.
注意:以上定义要求特定节点的所有属性定义必须在该节点的子节点定义之前 
尽管如果将属性和子节点混合在一起，这个结构将不会是模糊的
但是内核解析器要求属性首先出现(至少要到2.6.22)。
任何操纵一棵扁平树的工具都必须小心维护这个约束。
NOTE: The above definition requires that all property definitions for
a particular node MUST precede any subnode definitions for that node.
Although the structure would not be ambiguous if properties and
subnodes were intermingled, the kernel parser requires that the
properties come first (up until at least 2.6.22).  Any tools
manipulating a flattened tree must take care to preserve this
constraint.

4) Device tree "strings" block
为了节省空间，属性的名字，通常是多余的，分别存储在"strings"块中。
这个块仅仅是所有属性名连接在一起的零终止字符串
结构块中的设备-树属性定义将包含来自字符串块开头的偏移值。
In order to save space, property names, which are generally redundant,
are stored separately in the "strings" block. This block is simply the
whole bunch of zero terminated strings for all property names
concatenated together. The device-tree property definitions in the
structure block will contain offset values from the beginning of the
strings block.


III - Required content of the device tree
=========================================
警告:本文中定义的所有“linux,*”属性仅适用于一个扁平的设备树
如果您的平台使用了开放固件的真实实现或与开放固件客户端接口兼容的实现
这些属性将被创建通过在内核的prom_init()文件中跳转代码创建。
你必须添加代码去发现你板子的模式和设置平台号，然而当使用平台设备树入口指针的时候
没有prom_init() 传递，因此您必须自己提供这些属性


WARNING: All "linux,*" properties defined in this document apply only
to a flattened device-tree. If your platform uses a real
implementation of Open Firmware or an implementation compatible with
the Open Firmware client interface, those properties will be created
by the trampoline code in the kernel's prom_init() file. For example,
that's where you'll have to add code to detect your board model and
set the platform number. However, when using the flattened device-tree
entry point, there is no prom_init() pass, and thus you have to
provide those properties yourself.


1) Note about cells and address representation
----------------------------------------------
一般规则被记录在各种开放固件文档中，如果你选择使用设备树来描述总线
存在OF 平台绑定，您应该遵循规范。但是，内核不需要设备树描述每一个设备或总线
The general rule is documented in the various Open Firmware
documentations. If you choose to describe a bus with the device-tree
and there exist an OF bus binding, then you should follow the
specification. However, the kernel does not require every single
device or bus to be described by the device tree.
一般来说，设备地址的格式是由父总线类型定义的，基于 #address-cells 和#size-cells
#size-cells不能被继承，有子节点的每个节点都需要指明它。
内核要求根节点有这些属性对于映射在处理器总线下的设备定义数据格式
In general, the format of an address for a device is defined by the
parent bus type, based on the #address-cells and #size-cells
properties.  Note that the parent's parent definitions of #address-cells
and #size-cells are not inherited so every node with children must specify
them.  The kernel requires the root node to have those properties defining
addresses format for devices directly mapped on the processor bus.
这两个属性定义了表示地址和大小的“cell ”，一个cell 是一个32位的数字
例如，例如，如果两者都包含2，就像上面给出的示例树一样，那么地址和大小都由两个单元组成
每个都是一个64位的数字(cells被串接在一起，并且期望大端格式)
另一个例子是苹果固件定义它们的方式。一个地址的两个 cell ，一个大小的cell，
大多数32位的实现应该定义#address-cells  和#size-cells 为1，表示一个32位的值
一些32位处理器允许物理地址大于32位       这些处理器应该把#address-cells为2。
Those 2 properties define 'cells' for representing an address and a
size. A "cell" is a 32-bit number. For example, if both contain 2
like the example tree given above, then an address and a size are both
composed of 2 cells, and each is a 64-bit number (cells are
concatenated and expected to be in big endian format). Another example
is the way Apple firmware defines them, with 2 cells for an address
and one cell for a size.  Most 32-bit implementations should define
#address-cells and #size-cells to 1, which represents a 32-bit value.
Some 32-bit processors allow for physical addresses greater than 32
bits; these processors should define #address-cells as 2.
reg”属性总是一个a"address 
size"元组，地址和大小的cell是由总线的#address-cells和#size-cells指定的。
当一个总线支持多种多样的地址空间和其他的一些  相对于给定地址分配标志。(如prefetchable，等等。)
这些标志通常被添加到物理地址的顶层位，例如，一个PCI物理地址由3
个单元组成，底部两个包含实际地址本身，而顶部单元格包含地址空间指示、标志和PCI
总线和设备号。

"reg" properties are always a tuple of the type "address size" where
the number of cells of address and size is specified by the bus
#address-cells and #size-cells. When a bus supports various address
spaces and other flags relative to a given address allocation (like
prefetchable, etc...) those flags are usually added to the top level
bits of the physical address. For example, a PCI physical address is
made of 3 cells, the bottom two containing the actual address itself
while the top cell contains address space indication, flags, and pci
bus & device numbers.
对于支持动态分配的总线，这是一种被接受的做法，
不提供地址在reg(保持它为0)，虽然提供了一个标志标明这个地址是动态分配的，去提供一个独立的"assigned-addresses"属性
包含了完美分配的地址。有关详细信息，请参阅绑定的PCI。
For buses that support dynamic allocation, it's the accepted practice
to then not provide the address in "reg" (keep it 0) though while
providing a flag indicating the address is dynamically allocated, and
then, to provide a separate "assigned-addresses" property that
contains the fully allocated addresses. See the PCI OF bindings for
details.
一般情况下，如果它反照你的硬件，没有地址空间位和没有动态分配的简单总线优先
因为现有的内核地址解析函数将会在这个方框中工作。
如果您定义一个具有更复杂地址格式的总线类型，包括地址空间位之类的东西
你必须在prom_parse.c添加一个为你的总线类型的总线翻译器
In general, a simple bus with no address space bits and no dynamic
allocation is preferred if it reflects your hardware, as the existing
kernel address parsing functions will work out of the box. If you
define a bus type with a more complex address format, including things
like address space bits, you'll have to add a bus translator to the
prom_parse.c file of the recent kernels for your bus type.
“reg”属性只定义了给定总线内的地址和大小(如果#size-cells  为非0)
为了将地址向上转换(这是父地址，可能是CPU物理地址)，
所有总线都必须包含一个″ranges  ”属性。
如果“ range ”属性在给定的级别丢失，则假定转换 是不可能的
也就是说。在父总线上，寄存器是不可见的，总线的“ranges ”属性的格式是:
bus address, parent bus address, size

The "reg" property only defines addresses and sizes (if #size-cells is
non-0) within a given bus. In order to translate addresses upward
(that is into parent bus addresses, and possibly into CPU physical
addresses), all buses must contain a "ranges" property. If the
"ranges" property is missing at a given level, it's assumed that
translation isn't possible, i.e., the registers are not visible on the
parent bus.  The format of the "ranges" property for a bus is a list
of:

	bus address, parent bus address, size


"bus address"是总线节点定义的总线的格式
也就是说，对于一个PCI桥，它将是一个PCI地址
因此，bus address, parent bus address, size
为子设备定义了一系列地址，parent
bus address" 是该总线的父总线的格式。 例如，
对于一个PCI主机控制器，它将是一个CPU地址
。对于一种PCI <->  ISA桥,那将是一种PCI地址
它定义了父总线中的基本地址，在该区域中映射了该范围的开始。
"bus address" is in the format of the bus this bus node is defining,
that is, for a PCI bridge, it would be a PCI address. Thus, (bus
address, size) defines a range of addresses for child devices. "parent
bus address" is in the format of the parent bus of this bus. For
example, for a PCI host controller, that would be a CPU address. For a
PCI<->ISA bridge, that would be a PCI address. It defines the base
address in the parent bus where the beginning of that range is mapped.
对于一个新的64位板子的支持，我推荐2/2格式或者是苹果的2/1格式，
因为sizes通常适合一个32位的word，所以稍微紧凑一些
新的32位板子支持应使用使用1/1格式，除非处理器支持物理地址grea大于32位
在这种情况下建议使用2/1格式。
For new 64-bit board support, I recommend either the 2/2 format or
Apple's 2/1 format which is slightly more compact since sizes usually
fit in a single 32-bit word.   New 32-bit board support should use a
1/1 format, unless the processor supports physical addresses grea  ter
than 32-bits, in which case a 2/1 format is recommended.
或者，ranges属性可能是空的，标明寄存器使用同等映射转换在父总线上是可见的
换句话说，父类总线地址空间与子总线地址空间是相同的。
Alternatively, the "ranges" property may be empty, indicating that the
registers are visible on the parent bus using an identity mapping
translation.  In other words, the parent bus address space is the same
as the child bus address space.

2) Note about "compatible" properties
-------------------------------------
这些属性是可选的，但是在设备和根节点中推荐。
compatible属性的格式是连接的零终止字符串的列表
他们允许一种设备来表达与类似设备的兼容性
在某些情况下允许单个驱动程序与多个设备进行匹配，而不考虑它们的实际名称。
These properties are optional, but recommended in devices and the root
node. The format of a "compatible" property is a list of concatenated
zero terminated strings. They allow a device to express its
compatibility with a family of similar devices, in some cases,
allowing a single driver to match against several devices regardless
of their actual names.

3) Note about "name" properties
-------------------------------
虽然早期的一些开放固件的用户，像OldWorld macintoshes倾向于使用“name”属性的实际设备名
但是现在使用一个更接近设备类的名称(通常等于devicetype)是一种很好的做法
例如，现在，以太网控制器被命名为“ethernet”，这是一个额外的“model”属性，定义一个明确的
芯片类型和模式。
compatible 属性定义一个家庭，如果一个驱动程序可以驱动超过一个这样的芯片
但是，内核通常不会对“name”属性设置任何限制
简单地遵循标准和它的演进是一种很好的实践。

While earlier users of Open Firmware like OldWorld macintoshes tended
to use the actual device name for the "name" property, it's nowadays
considered a good practice to use a name that is closer to the device
class (often equal to device_type). For example, nowadays, Ethernet
controllers are named "ethernet", an additional "model" property
defining precisely the chip type/model, and "compatible" property
defining the family in case a single driver can driver more than one
of these chips. However, the kernel doesn't generally put any
restriction on the "name" property; it is simply considered good
practice to follow the standard and its evolutions as closely as
possible.
还要注意的是，新的格式版本16使“name”属性可选
如果节点不存在，那么节点的单位名称就会被用来重新构造名称
也就是说，在使用“@”符号之前，单元名称的一部分(
如果没有“@”符号，则表示整个单元名称)。
Note also that the new format version 16 makes the "name" property
optional. If it's absent for a node, then the node's unit name is then
used to reconstruct the name. That is, the part of the unit name
before the "@" sign is used (or the entire unit name if no "@" sign
is present).
注意节点和属性名和字符集
4) Note about node and property names and character set
-------------------------------------------------------
虽然开放固件提供了更灵活的8859-1的用法，但是这个规范实施了更严格的规则
节点和属性应该只包含ASCII字符a到'z'，'0'到'9''，''。'''+'，''?”和“-”。
节点名还允许大写字母“A”到“Z”，属性名应该是小写的。
像苹果这样的供应商不尊重这条规则的事实在这里是不相关的)
此外，节点和属性名应该总是以a到z(或“a”到“z”)的字符开头。
While Open Firmware provides more flexible usage of 8859-1, this
specification enforces more strict rules. Nodes and properties should
be comprised only of ASCII characters 'a' to 'z', '0' to
'9', ',', '.', '_', '+', '#', '?', and '-'. Node names additionally
allow uppercase characters 'A' to 'Z' (property names should be
lowercase. The fact that vendors like Apple don't respect this rule is
irrelevant here). Additionally, node and property names should always
begin with a character in the range 'a' to 'z' (or 'A' to 'Z' for node
names).
两个节点和属性名的最大字符数是31。
在节点名的情况下，这只是单元名称的最左部分(纯“name”属性)
，它不包括可以超出该限制范围的单元地址。
The maximum number of characters for both nodes and property names
is 31. In the case of node names, this is only the leftmost part of
a unit name (the pure "name" property), it doesn't include the unit
address which can extend beyond that limit.


5) Required nodes and properties
--------------------------------
这些都是目前所需要的。但是，强烈建议您将PCI
主机桥暴露在一种总线标准绑定中，以打开固件，并且在中断树规范中记录您的中断树。
  These are all that are currently required. However, it is strongly
  recommended that you expose PCI host bridges as documented in the
  PCI binding to Open Firmware, and your interrupt tree as documented
  in OF interrupt tree specification.

  a) The root node
根节点需要一些属性来显示
  The root node requires some properties to be present:

    - model : this is your board name/model
    root设备的地址表现
    - #address-cells : address representation for "root" devices
    - #size-cells: the size representation for "root" devices
    - compatible : the board "family" generally finds its way here,
      for example, if you have 2 board models with a similar layout,
      that typically get driven by the same platform code in the
      kernel, you would specify the exact board model in the
      compatible property followed by an entry that represents the SoC
      model.

根节点通常也会在你的板上添加额外的属性，比如序列号，如果有的话
建议如果您添加任何custom 属性，其名称可能与标准定义的名称冲突，那么您可以使用您的供应商名称和逗号来前缀它们
  The root node is also generally where you add additional properties
  specific to your board like the serial number if any, that sort of
  thing. It is recommended that if you add any "custom" property whose
  name may clash with standard defined ones, you prefix them with your
  vendor name and a comma.
根节点的附加属性:
  Additional properties for the root node:
串口号 :一个表示设备序列号的字符串
    - serial-number : a string representing the device's serial number

  b) The /cpus node
这个节点是所有单独的CPU
节点的父节点。它没有任何具体的要求，尽管通常至少有这样的良好实践:
  This node is the parent of all individual CPU nodes. It doesn't
  have any specific requirements, though it's generally good practice
  to have at least:

               #address-cells = <00000001>
               #size-cells    = <00000000>
这就定义了CPU的“address  ”是单个的cell，并且没有意义的size。
这是不必要的，但是在读取CPU节点的“reg”属性时，内核会假设这种格式如下所示
  This defines that the "address" for a CPU is a single cell, and has
  no meaningful size. This is not necessary but the kernel will assume
  that format when reading the "reg" properties of a CPU node, see
  below

  c) The /cpus/* nodes
因此，在/CPU下，您应该为机器上的每个CPU创建一个节点
对于CPU的名称，并没有特定的限制，尽管通常称它为“  <architecture>,<core>. ”。
例如，苹果使用PowerPC，G5，而IBM使用PowerPC，970 FX
。但是，通用名称约定表明，最好是简单地为每个cpu节点使用“cpu
”，并使用兼容的属性来标识特定的cpu内核。
  So under /cpus, you are supposed to create a node for every CPU on
  the machine. There is no specific restriction on the name of the
  CPU, though it's common to call it <architecture>,<core>. For
  example, Apple uses PowerPC,G5 while IBM uses PowerPC,970FX.
  However, the Generic Names convention suggests that it would be
  better to simply use 'cpu' for each cpu node and use the compatible
  property to identify the specific cpu core.

  Required properties:

    - device_type : has to be "cpu"
这是物理CPU号，它是一个32位的cell，这是物理CPU号，它是一个32
位的单元格，并且作为单元号在完整路径中构造单元名，也被作为单元号使用。例如，使
2个cpu，您将拥有完整的路径
    - reg : This is the physical CPU number, it's a single 32-bit cell
      and is also used as-is as the unit number for constructing the
      unit name in the full path. For example, with 2 CPUs, you would
      have the full path:
        /cpus/PowerPC,970FX@0
        /cpus/PowerPC,970FX@1
        单位地址不需要0
      (unit addresses do not require leading zeroes)
    - d-cache-block-size : one cell, L1 data cache block size in bytes (*)
    - i-cache-block-size : one cell, L1 instruction cache block size in
      bytes
    - d-cache-size : one cell, size of L1 data cache in bytes
    - i-cache-size : one cell, size of L1 instruction cache in bytes
缓存的“ block ”大小是缓存管理指令操作的大小
历史上，这个文档使用了缓存的“行”大小，这是不正确的。内核更倾向于缓存块大小，
并将返回缓存行大小以支持向后兼容性。
(*) The cache "block" size is the size on which the cache management
instructions operate. Historically, this document used the cache
"line" size here which is incorrect. The kernel will prefer the cache
block size and will fallback to cache line size for backward
compatibility.

  Recommended properties:
 timebase-frequency:一个表示赫兹的时间基频率的cell,
    - timebase-frequency : a cell indicating the frequency of the
      timebase in Hz. This is not directly used by the generic code,
      but you are welcome to copy/paste the pSeries code for setting
      the kernel timebase/decrementer calibration based on this
      value.
    - clock-frequency : a cell indicating the CPU core clock frequency
      in Hz. A new property will be defined for 64-bit values, but if
      your frequency is < 4Ghz, one cell is enough. Here as well as
      for the above, the common code doesn't use that property, but
      you are welcome to re-use the pSeries or Maple one. A future
      kernel version might provide a common function for this.
    - d-cache-line-size : one cell, L1 data cache line size in bytes
      if different from the block size
    - i-cache-line-size : one cell, L1 instruction cache line size in
      bytes if different from the block size
欢迎你添加任何相关的任何属性给你的板子比如一些有关用于软重置cpu的机制的信息。
例如，苹果将CPU软中断 的GPIO号在soft-reset属性中，因为它们通过软重置来启动二级CPU
  You are welcome to add any property you find relevant to your board,
  like some information about the mechanism used to soft-reset the
  CPUs. For example, Apple puts the GPIO number for CPU soft reset
  lines in there as a "soft-reset" property since they start secondary
  CPUs by soft-resetting them.


  d) the /memory node(s)
为了给你的板子进行物理内存布局，你应该创建一个或者多个内存节点，
您可以在reg 属性中创建一个具有所有内存范围的单个节点，也可以按照您的意愿创建多个节点
用于完整路径的单元地址(@ part)是给定节点定义的第一个内存范围的地址
  To define the physical memory layout of your board, you should
  create one or more memory node(s). You can either create a single
  node with all memory ranges in its reg property, or you can create
  several nodes, as you wish. The unit address (@ part) used for the
  full path is the address of the first range of memory defined by a
  given node. If you use a single memory node, this will typically be
  @0.

  Required properties:

    - device_type : has to be "memory"
    该属性包含了您的 板子 的所有物理内存范围
    它是连接到一起的地址/大小的列表。
    其中每个单元格的数目由根节点的  #address-cells和#size-cells 的cells 所定义
    例如，在早期给的例子中，所有的这些属性都变成了2。
    一个基于970的机器，有6Gb的RAM，通常在这里有一个“reg”属性，看起来像:
    - reg : This property contains all the physical memory ranges of
      your board. It's a list of addresses/sizes concatenated
      together, with the number of cells of each defined by the
      #address-cells and #size-cells of the root node. For example,
      with both of these properties being 2 like in the example given
      earlier, a 970 based machine with 6Gb of RAM could typically
      have a "reg" property here that looks like:

      00000000 00000000 00000000 80000000
      00000001 00000000 00000001 00000000

这是一个从0x80000000字节开始的范围，一个范围从0x100000000和0x100000000
字节开始。你可以看到，在2Gb  和4GB 之间没有内存覆盖IO洞。
一些供应商倾向于将这些范围划分为更小的部分，但是内核并不关心




      That is a range starting at 0 of 0x80000000 bytes and a range
      starting at 0x100000000 and of 0x100000000 bytes. You can see
      that there is no memory covering the IO hole between 2Gb and
      4Gb. Some vendors prefer splitting those ranges into smaller
      segments, but the kernel doesn't care.

  e) The /chosen node
这个节点有点特殊。通常情况下
通常情况下，开放固件会将一些可变的环境信息，比如参数，或者默认的输入/输出设备放
在这里。
  This node is a bit "special". Normally, that's where Open Firmware
  puts some variable environment information, like the arguments, or
  the default input/output devices.
这个规范有一些强制性的，但是也定义了一些特定于linux的特性，
这些属性通常是在prom_init()properties 构造的。当通过OF 客户借口启动时。
但是您必须在使用扁平格式时提供自己。
  This specification makes a few of these mandatory, but also defines
  some linux-specific properties that would be normally constructed by
  the prom_init() trampoline when booting with an OF client interface,
  but that you have to provide yourself when using the flattened format.
推荐的属性:
  Recommended properties:
bootargs : 这个零终止的字符串作为内核命令行传递
    - bootargs : This zero-terminated string is passed as the kernel
      command line
linux,stdout-path
如果有的话，这是标准控制台设备的完整路径
通常，如果在你的板子上有串行设备，您可能希望将完整的路径设置为在固件中默认的控制台
以便内核将其作为它自己的默认控制台进行选择。
    - linux,stdout-path : This is the full path to your standard
      console device if any. Typically, if you have serial devices on
      your board, you may want to put the full path to the one set as
      the default console in the firmware here, for the kernel to pick
      it up as its own default console.
注意uboot创建和填充这个chosen节点便于platforms使用它
  Note that u-boot creates and fills in the chosen node for platforms
  that use it.
注意:现在已经过时的一种做法是在chosen下面一个叫interrupt-controller的属性，该属性具有指向主中断控制器的phandle值
  (Note: a practice that is now obsolete was to include a property
  under /chosen called interrupt-controller which had a phandle value
  that pointed to the main interrupt controller)

  f) the /soc<SOCname> node
该节点用于表示系统-a-芯片(SoC)，该节点用于表示系统-a-芯片(SoC)，如果处理器是SoC，则必须显示该节点
顶层soc节点包含了对soc所有设备的全局信息。节点名应该包含SoC的一个单元地址，SoC节点的名称应该以“SoC”开头
而该名称的其余部分应该表示SoC的部件编号，例如，MPC8540的soc节点将被称为“soc8540”。
  This node is used to represent a system-on-a-chip (SoC) and must be
  present if the processor is a SoC. The top-level soc node contains
  information that is global to all devices on the SoC. The node name
  should contain a unit address for the SoC, which is the base address
  of the memory-mapped register set for the SoC. The name of an SoC
  node should start with "soc", and the remainder of the name should
  represent the part number for the soc.  For example, the MPC8540's
  soc node would be called "soc8540".
所需的属性 :
  Required properties:
应在被定义在1)中有详细说明来描述用于内存映射SoC寄存器的SoC地址的转换。
    - ranges : Should be defined as specified in 1) to describe the
      translation of SoC addresses for memory mapped SoC registers.
bus-frequency :     包含SoC节点的总线频率。通常，这个字段的值由引导装载程序填充。 
    - bus-frequency: Contains the bus frequency for the SoC node.
      Typically, the value of this field is filled in by the boot
      loader.
      
    - compatible : Exact model of the SoC

推荐属性
  Recommended properties:
reg:这个属性定义了用于SOC节点本身的内存映射寄存器的地址和大小。
它不包括子设备寄存器――这些将在每个子节点内定义。
在“reg”属性中指定的地址应该与SOC节点的单元地址匹配

    - reg : This property defines the address and size of the
      memory-mapped registers that are used for the SOC node itself.
      It does not include the child device registers - these will be
      defined inside each child node.  The address specified in the
      "reg" property should match the unit address of the SOC node.
 #address-cells : “soc”设备的地址表示。该字段的格式可能会因设备寄存器是否为内存映射而异。
 对于内存映射寄存器，这个字段表示 cells的数目需要表示寄存器地址的。
 对于不使用MMIO的SOCs，对于不使用MMIO的SOCs，应该定义一个特殊的地址格式，其中包含足够的单元格来表示所需的信息
 参见1)关于定义地址-单元格的更多细节。
    - #address-cells : Address representation for "soc" devices.  The
      format of this field may vary depending on whether or not the
      device registers are memory mapped.  For memory mapped
      registers, this field represents the number of cells needed to
      represent the address of the registers.  For SOCs that do not
      use MMIO, a special address format should be defined that
      contains enough cells to represent the required information.
      See 1) above for more details on defining #address-cells.
 #size-cells :     “soc”设备的大小表示
    - #size-cells : Size representation for "soc" devices
  #interrupt-cells :  定义用于表示中断的 cell  的宽度。
  通常这个值是2，其中包括一个代表中断数的32位数字
  其中一个表示中断的功能和等级。
  只有当SOC包含一个中断控制器时，才需要这个字段
  
    - #interrupt-cells : Defines the width of cells used to represent
       interrupts.  Typically this value is <2>, which includes a
       32-bit number that represents the interrupt number, and a
       32-bit number that represents the interrupt sense and level.
       This field is only needed if the SOC contains an interrupt
       controller.
SOC节点可能包含平台使用的每个SOC设备的子节点，
不应该为存在于SOC的设备创建节点，而不为特定平台使用
请参阅第六章，了解更多关于如何指定属于SOC的设备的信息。
  The SOC node may contain child nodes for each SOC device that the
  platform uses.  Nodes should not be created for devices which exist
  on the SOC but are not used by a particular platform. See chapter VI
  for more information on how to specify devices that are part of a SOC.

  Example SOC node for the MPC8540:

	soc8540@e0000000 {
		#address-cells = <1>;
		#size-cells = <1>;
		#interrupt-cells = <2>;
		device_type = "soc";
		ranges = <0x00000000 0xe0000000 0x00100000>
		reg = <0xe0000000 0x00003000>;
		bus-frequency = <0>;
	}



IV - "dtc", the device tree compiler
====================================


dtc source code can be found at
<http://git.jdl.com/gitweb/?p=dtc.git>
警告:这个版本还处于早期开发阶段,最终的设备树“blob”还没有被内核验证。
当前生成的块缺少一个有用的保留映射(它将被固定以生成一个空的映射，它取决于bootloader   来填充它)。
错误处理需要工作，bug在潜伏，等等。
WARNING: This version is still in early development stage; the
resulting device-tree "blobs" have not yet been validated with the
kernel. The current generated block lacks a useful reserve map (it will
be fixed to generate an empty one, it's up to the bootloader to fill
it up) among others. The error handling needs work, bugs are lurking,
etc...
dtc
基本上以一种给定的格式接收设备树，并以另一种格式输出设备树。目前支持的格式是:
dtc basically takes a device-tree in a given format and outputs a
device-tree in another format. The currently supported formats are:
输入格式:
- - - - - - - - - - - - -
“dtb”:“blob”格式，它是一个扁平的设备树块，它的头都是一个二进制的blob。
“dts”:“源”格式。这是一个文本文件，其中包含了一个设备树的“源”。该格式在本章后面
定义。

-“fs”格式。这是一个等价于/proc/device-tree 的输出，即节点是目录，属性是文件
  Input formats:
  -------------

     - "dtb": "blob" format, that is a flattened device-tree block
       with
        header all in a binary blob.
     - "dts": "source" format. This is a text file containing a
       "source" for a device-tree. The format is defined later in this
        chapter.
     - "fs" format. This is a representation equivalent to the
        output of /proc/device-tree, that is nodes are directories and
	properties are files

 Output formats:
 ---------------

     - "dtb": "blob" format
     - "dts": "source" format
" asm ":汇编语言文件。这是一个可以由气体来源的文件，可以生成一个设备树“blob”
此外，汇编文件导出了一些可以使用的符号
     - "asm": assembly language file. This is a file that can be
       sourced by gas to generate a device-tree "blob". That file can
       then simply be added to your Makefile. Additionally, the
       assembly file exports some symbols that can be used.

dtc工具的语法是
The syntax of the dtc tool is

    dtc [-I <input-format>] [-O <output-format>]
        [-o output-filename] [-V output_version] input_filename

output_version定义了将生成的“blob”格式的版本，支持的版本是1,2,3和16
默认情况是当前版本3，但将来可能会更改为16版本。
The "output_version" defines what version of the "blob" format will be
generated. Supported versions are 1,2,3 and 16. The default is
currently version 3 but that may change in the future to version 16.
另外，dtc对树进行了各种各样的检查，比如linux的惟一性、phandle
属性、字符串的有效性等等。
Additionally, dtc performs various sanity checks on the tree, like the
uniqueness of linux, phandle properties, validity of strings, etc...
它的格式.dts“ source ”文件像 “C”，支持C和C++风格的注释。
The format of the .dts "source" file is "C" like, supports C and C++
style comments.

/ {
}
上面是“设备树”的定义，这是目前在顶层  中唯一支持的语句。
The above is the "device-tree" definition. It's the only statement
supported currently at the toplevel.

/ {
定义一个包含0终止字符串的属性
  property1 = "string_value";	/* define a property containing a 0
                                 * terminated string
				 */
定义一个包含数字32位值(十六进制)的属性。
  property2 = <0x1234abcd>;	/* define a property containing a
                                 * numerical 32-bit value (hexadecimal)
				 */
定义一个包含3个数字32位16进制 ( cell)的属性。

  property3 = <0x12345678 0x12345678 0xdeadbeef>;
                                /* define a property containing 3
                                 * numerical 32-bit values (cells) in
                                 * hexadecimal
				 */
定义一个属性，它的内容是一个任意的字节数组
  property4 = [0x0a 0x0b 0x0c 0x0d 0xde 0xea 0xad 0xbe 0xef];
                                /* define a property whose content is
                                 * an arbitrary array of bytes
                                 */
定义一个名为“childnode”的子节点
它的单位名是“子节点”*地址”

  childnode@address {	/* define a child node named "childnode"
                                 * whose unit name is "childnode at
				 * address"
                                 */

    childprop = "hello\n";      /* define a property "childprop" of
                                 * childnode (in this case, a string)
                                 */
  };
};
节点可以包含其他节点等等。这样就定义了树的层次结构。
Nodes can contain other nodes etc... thus defining the hierarchical
structure of the tree.

字符串支持来自C的常见转义序列:“n”、“t”、“r”、“(八进制值)"," \ x(
十六进制值)”。
Strings support common escape sequences from C: "\n", "\t", "\r",
"\(octal value)", "\x(hex value)".
还建议您通过cpp(gcc预处理器)来管道您的源文件，这样您就可以使用include
，为常量定义，等等。
It is also suggested that you pipe your source file through cpp (gcc
preprocessor) so you can use #include's, #define for constants, etc...
最后,各种选项计划但尚未实现,像phandles的自动生成, lables
(   导出 到asm文件你可以指向一个 属性  内容和改变它很容易  
不管你链接的设备树)，标签和路径代替了一些cell的数值用来指向某个节点
在编译时被phandle取代，给asm文件 导出的保留映射地址，有能力 在编译时指定保留映射内容
Finally, various options are planned but not yet implemented, like
automatic generation of phandles, labels (exported to the asm file so
you can point to a property content and change it easily from whatever
you link the device-tree with), label or path instead of numeric value
in some cells to "point" to a node (replaced by a phandle at compile
time), export of reserve map address to the asm file, ability to
specify reserve map content at compile time, etc...
我们可以提供一个.h 的头文件  对某些属性的常用定义
(比如构建PCI属性或中断映射)，尽管最好将struct定义的概念添加到编译器中。
We may provide a .h include file with common definitions of that
proves useful for some properties (like building PCI properties or
interrupt maps) though it may be better to add a notion of struct
definitions to the compiler...

V - bootloader的加载
V - Recommendations for a bootloader
====================================

这里是一些已经被提议的不同的想法/建议，而所有这些都已经被定义和实现了。
Here are some various ideas/recommendations that have been proposed
while all this has been defined and implemented.
bootloader可能希望能够使用设备本身，并可能希望操纵它(用于添加/编辑某些属性，比如物理内存大小或内核参数)。
在这一点上，可以做出两种选择，bootloader可以直接在被压扁的格式上工作，
或者  bootloader  有自己的内部树表示  
其中有指针(类似于内核)，并且在引导内核时重新使树扁平。前者对于编辑/修改有些困难
后者可能需要更多的代码来处理树结构。注意，结构格式已经被设计好了，所以“插入”属性或节点相对容易，
或者仅仅通过在周围移动东西来删除它们
它不包含用于此目的的内部偏移量或指针。
  - The bootloader may want to be able to use the device-tree itself
    and may want to manipulate it (to add/edit some properties,
    like physical memory size or kernel arguments). At this point, 2
    choices can be made. Either the bootloader works directly on the
    flattened format, or the bootloader has its own internal tree
    representation with pointers (similar to the kernel one) and
    re-flattens the tree when booting the kernel. The former is a bit
    more difficult to edit/modify, the later requires probably a bit
    more code to handle the tree structure. Note that the structure
    format has been designed so it's relatively easy to "insert"
    properties or nodes or delete them by just memmoving things
    around. It contains no internal offsets or pointers for this
    purpose.
在内核文件驱动程序/oft/fdt.c中，可以找到一个直接从被扁的树格式中迭代节点和检索属性的代码示例
看一下of_scan_flat_dt()函数，在early_init_devtree中使用。以及相应的各种早期early_init_dt_scan_*()回调函数。
这段代码可以在GPL bootloader中重新使用，作为该代码的作者，
我很乐意讨论可能的免费授权给任何希望将所有或部分代码集成到非GPL引导程序的供应商
  - An example of code for iterating nodes & retrieving properties
    directly from the flattened tree format can be found in the kernel
    file drivers/of/fdt.c.  Look at the of_scan_flat_dt() function,
    its usage in early_init_devtree(), and the corresponding various
    early_init_dt_scan_*() callbacks. That code can be re-used in a
    GPL bootloader, and as the author of that code, I would be happy
    to discuss possible free licensing to any vendor who wishes to
    integrate all or part of this code into a non-GPL bootloader.
    (reference needed; who is 'I' here? ---gcl Jan 31, 2011)


系统级芯片设备和节点
VI - System-on-a-chip devices and nodes
=======================================
许多公司现在开始开发系统-芯片处理器，处理器核心(CPU)和许多外围设备都存在于一块硅片上
对于这些SOCs，应该使用SOC节点来定义组成SOC的设备的子节点。非常高的支持关于
所有SOC的实现都定义为完整的平设备树来描述SOC上的设备。
这将允许对大部分的内核代码进行泛化。
Many companies are now starting to develop system-on-a-chip
processors, where the processor core (CPU) and many peripheral devices
exist on a single piece of silicon.  For these SOCs, an SOC node
should be used that defines child nodes for the devices that make
up the SOC. While platforms are not required to use this model in
order to boot the kernel, it is highly encouraged that all SOC
implementations define as complete a flat-device-tree as possible to
describe the devices on the SOC.  This will allow for the
genericization of much of the kernel code.


1) Defining child nodes of an SOC
---------------------------------
作为SOC的一部分的每个设备在SOC节点中都有自己的节点条目
对于包含在SOC中的每个设备，单元地址属性代表了该设备在父地址空间中的内存映射寄存器的地址偏移量。
父地址空间是由顶级soc节点的“ranges”属性定义的
对于直接在SOC节点下存在的每个节点的“reg”属性应该包含从子地址空间到父SOC
地址空间的地址映射，以及设备的内存映射寄存器文件的大小。
Each device that is part of an SOC may have its own node entry inside
the SOC node.  For each device that is included in the SOC, the unit
address property represents the address offset for this device's
memory-mapped registers in the parent's address space.  The parent's
address space is defined by the "ranges" property in the top-level soc
node. The "reg" property for each node that exists directly under the
SOC node should contain the address mapping from the child address space
to the parent SOC address space and the size of the device's
memory-mapped register file.
对于可能存在于SOC内部的许多设备，对于设备树节点的格式有预定义的规范。所有SOC
子节点都应该遵循这些规范，除非在本文档中注明。
For many devices that may exist inside an SOC, there are predefined
specifications for the format of the device tree node.  All SOC child
nodes should follow these specifications, except where noted in this
document.
请参阅附录A，以获得MPC8540的部分SOC节点定义。
See appendix A for an example partial SOC node definition for the
MPC8540.

代表没有通用的OF 规则的设备
2) Representing devices without a current OF specification
----------------------------------------------------------
目前，在SoCs中有许多设备没有标准的表示形式，它们被定义为开放固件规范的一部分，
主要是因为包含这些SoCs的 板子   目前还没有使用开放固件引导。
为新设备绑定文档应该被添加到文档 Documentation/devicetree/bindings 目录。
随着设备树支持被添加到越来越多的SoCs中，这个目录将会扩展。
Currently, there are many devices on SoCs that do not have a standard
representation defined as part of the Open Firmware specifications,
mainly because the boards that contain these SoCs are not currently
booted using Open Firmware.  Binding documentation for new devices
should be added to the Documentation/devicetree/bindings directory.
That directory will expand as device tree support is added to more and
more SoCs.

为设备指定中断信息
VII - Specifying interrupt information for devices
===================================================
设备树表示硬件系统的总线和设备，其形式类似于硬件的物理总线拓扑结构。
The device tree represents the buses and devices of a hardware
system in a form similar to the physical bus topology of the
hardware.
此外，还存在一个逻辑“中断树”，它表示硬件中的中断的层次结构和路由。
In addition, a logical 'interrupt tree' exists which represents the
hierarchy and routing of interrupts in the hardware.
在文档“Open Firmware Recommended Practice: Interrupt Mapping Version 0.9”中，对中断树模型进行了全面的描述。
The interrupt tree model is fully described in the
document "Open Firmware Recommended Practice: Interrupt
Mapping Version 0.9".  The document is available at:
<http://www.openfirmware.org/ofwg/practice/>

1) interrupts property
----------------------
单个中断控制器产生中断的设备应该使用传统的OF 在OF中断映射文档中描述
Devices that generate interrupts to a single interrupt controller
should use the conventional OF representation described in the
OF interrupt mapping documentation.
每一个产生中断的设备都必须有一个“'interrupt”属性。
中断属性值是一个任意数量的“' interrupt specifier”值
它描述了设备的中断或中断。
Each device which generates interrupts must have an 'interrupt'
property.  The interrupt property value is an arbitrary number of
of 'interrupt specifier' values which describe the interrupt or
interrupts for the device.
中断说明符的编码是由这个设备位于中断树上的中断域来决定的。
一个中断域的根指定在它的#interrupt-cells 属性，32位cells
The encoding of an interrupt specifier is determined by the
interrupt domain in which the device is located in the
interrupt tree.  The root of an interrupt domain specifies in
its #interrupt-cells property the number of 32-bit cells
required to encode an interrupt specifier.  See the OF interrupt
mapping documentation for a detailed description of domains.
例如 OpenPIC中断控制器的绑定指定一个#interrupt-cells 的值是2  去编码这个中断号和
水平/功能信息。所有中断的  子节点 在他们的中断属性中都使用了2个cell。
For example, the binding for the OpenPIC interrupt controller
specifies  an #interrupt-cells value of 2 to encode the interrupt
number and level/sense information. All interrupt children in an
OpenPIC interrupt domain use 2 cells per interrupt in their interrupts
property.
PCI总线绑定了指定的 #interrupt-cell 的值是1 去编码(INTA,INTB,INTC,INTD)中断引脚
The PCI bus binding specifies a #interrupt-cell value of 1 to encode
which interrupt pin (INTA,INTB,INTC,INTD) is used.

2) interrupt-parent property
----------------------------
interrupt-parent属性被指定在中断树中设备节点和它的中断父母中显示链接
interrupt-parent 的值是父节点的phandle
The interrupt-parent property is specified to define an explicit
link between a device node and its interrupt parent in
the interrupt tree.  The value of interrupt-parent is the
phandle of the parent node.
如果 interrupt-parent  属性没有节点定义，它的中断父节点被假定成一个祖先在这个节点的_device tree_层次
If the interrupt-parent property is not defined for a node, its
interrupt parent is assumed to be an ancestor in the node's
_device tree_ hierarchy.

3) OpenPIC Interrupt Controllers
--------------------------------
OpenPIC中断控制器需要两个  cell  来编码中断信息。
第一个单元格定义了中断编号。第二个单元格定义了 功能 和 层次 信息。
OpenPIC interrupt controllers require 2 cells to encode
interrupt information.  The first cell defines the interrupt
number.  The second cell defines the sense and level
information.
功能和层次信息应该被定义如下
Sense and level information should be encoded as follows:
低到高
	0 = low to high edge sensitive type enabled
低活跃	
	1 = active low level sensitive type enabled
高活跃
	2 = active high level sensitive type enabled
高到低
	3 = high to low edge sensitive type enabled

4) ISA Interrupt Controllers
----------------------------
ISA PIC中断控制器需要两个CELLS编码中断信息。
第一个CELL定义这个中断号，跌热定义功能和层次信息
ISA PIC interrupt controllers require 2 cells to encode
interrupt information.  The first cell defines the interrupt
number.  The second cell defines the sense and level
information.

ISA PIC interrupt controllers should adhere to the ISA PIC
encodings listed below:

	0 =  active low level sensitive type enabled
	1 =  active high level sensitive type enabled
	2 =  high to low edge sensitive type enabled
	3 =  low to high edge sensitive type enabled
指定设备电源管理信息(睡眠属性)
VIII - Specifying Device Power Management Information (sleep property)
===================================================================
在SOCs 上的设备通常有将设备放置于低功耗状态的机制，这些设备与设备自身的寄存器块是分离
有时，这些信息比一个cell-index 属性能够合理描述的要复杂得多
因此，以这种方式控制的每个设备可能包含一个描述这些连接的“sleep”属性。
Devices on SOCs often have mechanisms for placing devices into low-power
states that are decoupled from the devices' own register blocks.  Sometimes,
this information is more complicated than a cell-index property can
reasonably describe.  Thus, each device controlled in such a manner
may contain a "sleep" property which describes these connections.

The sleep property consists of one or more sleep resources, each of
which consists of a phandle to a sleep controller, followed by a
controller-specific sleep specifier of zero or more cells.

The semantics of what type of low power modes are possible are defined
by the sleep controller.  Some examples of the types of low power modes
that may be supported are:

 - Dynamic: The device may be disabled or enabled at any time.
 - System Suspend: The device may request to be disabled or remain
   awake during system suspend, but will not be disabled until then.
 - Permanent: The device is disabled permanently (until the next hard
   reset).

Some devices may share a clock domain with each other, such that they should
only be suspended when none of the devices are in use.  Where reasonable,
such nodes should be placed on a virtual bus, where the bus has the sleep
property.  If the clock domain is shared among devices that cannot be
reasonably grouped in this manner, then create a virtual sleep controller
(similar to an interrupt nexus, except that defining a standardized
sleep-map should wait until its necessity is demonstrated).

IX - Specifying dma bus information

Some devices may have DMA memory range shifted relatively to the beginning of
RAM, or even placed outside of kernel RAM. For example, the Keystone 2 SoC
worked in LPAE mode with 4G memory has:
- RAM range: [0x8 0000 0000, 0x8 FFFF FFFF]
- DMA range: [  0x8000 0000,   0xFFFF FFFF]
and DMA range is aliased into first 2G of RAM in HW.

In such cases, DMA addresses translation should be performed between CPU phys
and DMA addresses. The "dma-ranges" property is intended to be used
for describing the configuration of such system in DT.

In addition, each DMA master device on the DMA bus may or may not support
coherent DMA operations. The "dma-coherent" property is intended to be used
for identifying devices supported coherent DMA operations in DT.

* DMA Bus master
Optional property:
- dma-ranges: <prop-encoded-array> encoded as arbitrary number of triplets of
	(child-bus-address, parent-bus-address, length). Each triplet specified
	describes a contiguous DMA address range.
	The dma-ranges property is used to describe the direct memory access (DMA)
	structure of a memory-mapped bus whose device tree parent can be accessed
	from DMA operations originating from the bus. It provides a means of
	defining a mapping or translation between the physical address space of
	the bus and the physical address space of the parent of the bus.
	(for more information see ePAPR specification)

* DMA Bus child
Optional property:
- dma-ranges: <empty> value. if present - It means that DMA addresses
	translation has to be enabled for this device.
- dma-coherent: Present if dma operations are coherent

Example:
soc {
		compatible = "ti,keystone","simple-bus";
		ranges = <0x0 0x0 0x0 0xc0000000>;
		dma-ranges = <0x80000000 0x8 0x00000000 0x80000000>;

		[...]

		usb: usb@2680000 {
			compatible = "ti,keystone-dwc3";

			[...]
			dma-coherent;
		};
};

Appendix A - Sample SOC node for MPC8540
========================================

	soc@e0000000 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "fsl,mpc8540-ccsr", "simple-bus";
		device_type = "soc";
		ranges = <0x00000000 0xe0000000 0x00100000>
		bus-frequency = <0>;
		interrupt-parent = <&pic>;

		ethernet@24000 {
			#address-cells = <1>;
			#size-cells = <1>;
			device_type = "network";
			model = "TSEC";
			compatible = "gianfar", "simple-bus";
			reg = <0x24000 0x1000>;
			local-mac-address = [ 0x00 0xE0 0x0C 0x00 0x73 0x00 ];
			interrupts = <0x29 2 0x30 2 0x34 2>;
			phy-handle = <&phy0>;
			sleep = <&pmc 0x00000080>;
			ranges;

			mdio@24520 {
				reg = <0x24520 0x20>;
				compatible = "fsl,gianfar-mdio";

				phy0: ethernet-phy@0 {
					interrupts = <5 1>;
					reg = <0>;
				};

				phy1: ethernet-phy@1 {
					interrupts = <5 1>;
					reg = <1>;
				};

				phy3: ethernet-phy@3 {
					interrupts = <7 1>;
					reg = <3>;
				};
			};
		};

		ethernet@25000 {
			device_type = "network";
			model = "TSEC";
			compatible = "gianfar";
			reg = <0x25000 0x1000>;
			local-mac-address = [ 0x00 0xE0 0x0C 0x00 0x73 0x01 ];
			interrupts = <0x13 2 0x14 2 0x18 2>;
			phy-handle = <&phy1>;
			sleep = <&pmc 0x00000040>;
		};

		ethernet@26000 {
			device_type = "network";
			model = "FEC";
			compatible = "gianfar";
			reg = <0x26000 0x1000>;
			local-mac-address = [ 0x00 0xE0 0x0C 0x00 0x73 0x02 ];
			interrupts = <0x41 2>;
			phy-handle = <&phy3>;
			sleep = <&pmc 0x00000020>;
		};

		serial@4500 {
			#address-cells = <1>;
			#size-cells = <1>;
			compatible = "fsl,mpc8540-duart", "simple-bus";
			sleep = <&pmc 0x00000002>;
			ranges;

			serial@4500 {
				device_type = "serial";
				compatible = "ns16550";
				reg = <0x4500 0x100>;
				clock-frequency = <0>;
				interrupts = <0x42 2>;
			};

			serial@4600 {
				device_type = "serial";
				compatible = "ns16550";
				reg = <0x4600 0x100>;
				clock-frequency = <0>;
				interrupts = <0x42 2>;
			};
		};

		pic: pic@40000 {
			interrupt-controller;
			#address-cells = <0>;
			#interrupt-cells = <2>;
			reg = <0x40000 0x40000>;
			compatible = "chrp,open-pic";
			device_type = "open-pic";
		};

		i2c@3000 {
			interrupts = <0x43 2>;
			reg = <0x3000 0x100>;
			compatible  = "fsl-i2c";
			dfsrr;
			sleep = <&pmc 0x00000004>;
		};

		pmc: power@e0070 {
			compatible = "fsl,mpc8540-pmc", "fsl,mpc8548-pmc";
			reg = <0xe0070 0x20>;
		};
	};
